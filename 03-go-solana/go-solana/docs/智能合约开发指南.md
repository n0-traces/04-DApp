# Token Swap 智能合约

这是一个使用 Solana 和 Anchor 框架开发的 Token Swap 智能合约示例。

## 项目结构

```
token-swap/
├── programs/
│   └── token-swap/
│       ├── src/
│       │   ├── lib.rs          # 主程序入口
│       │   ├── instructions.rs  # 指令处理
│       │   ├── state.rs        # 状态定义
│       │   └── errors.rs       # 错误定义
│       └── Cargo.toml
├── tests/
│   └── token-swap.ts
├── migrations/
│   └── deploy.ts
└── Anchor.toml
```

## 功能特性

1. **初始化流动性池** - 创建新的代币交换池
2. **添加流动性** - 向池中添加代币对
3. **移除流动性** - 从池中提取代币
4. **代币交换** - 使用恒定乘积做市商 (CPMM) 算法进行交换
5. **查询池信息** - 获取流动性池的当前状态

## 核心概念

### 恒定乘积公式 (Constant Product)
```
x * y = k
```
其中：
- x = Token A 的储备量
- y = Token B 的储备量
- k = 常数

### 交易手续费
- 交易手续费: 0.3% (30/10000)
- 手续费分配给流动性提供者

## 安装依赖

### 安装 Solana CLI
```bash
sh -c "$(curl -sSfL https://release.solana.com/stable/install)"
```

### 安装 Anchor CLI
```bash
cargo install --git https://github.com/coral-xyz/anchor anchor-cli --locked
```

### 安装 Rust
```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
rustup component add rustfmt
```

## 使用 CLI 生成合约骨架

```bash
# 创建新项目
anchor init token-swap

# 或使用 solana-program-cli (Go)
solana-program-cli new --lang=rust token-swap

# 移动到项目目录
mv token-swap /path/to/your/workspace
```

## 合约代码示例

### lib.rs - 主程序入口

```rust
use anchor_lang::prelude::*;

declare_id!("YourProgramIDHere111111111111111111111111111");

pub mod instructions;
pub mod state;
pub mod errors;

use instructions::*;

#[program]
pub mod token_swap {
    use super::*;

    // 初始化流动性池
    pub fn initialize(
        ctx: Context<Initialize>,
        fee_numerator: u64,
        fee_denominator: u64,
    ) -> Result<()> {
        instructions::initialize(ctx, fee_numerator, fee_denominator)
    }

    // 添加流动性
    pub fn add_liquidity(
        ctx: Context<AddLiquidity>,
        amount_a: u64,
        amount_b: u64,
    ) -> Result<()> {
        instructions::add_liquidity(ctx, amount_a, amount_b)
    }

    // 移除流动性
    pub fn remove_liquidity(
        ctx: Context<RemoveLiquidity>,
        liquidity_amount: u64,
    ) -> Result<()> {
        instructions::remove_liquidity(ctx, liquidity_amount)
    }

    // 交换代币
    pub fn swap(
        ctx: Context<Swap>,
        amount_in: u64,
        minimum_amount_out: u64,
    ) -> Result<()> {
        instructions::swap(ctx, amount_in, minimum_amount_out)
    }
}
```

### state.rs - 状态定义

```rust
use anchor_lang::prelude::*;

#[account]
pub struct LiquidityPool {
    pub authority: Pubkey,          // 池管理员
    pub token_a_mint: Pubkey,       // Token A Mint
    pub token_b_mint: Pubkey,       // Token B Mint
    pub token_a_vault: Pubkey,      // Token A 金库
    pub token_b_vault: Pubkey,      // Token B 金库
    pub lp_token_mint: Pubkey,      // LP Token Mint
    pub fee_numerator: u64,         // 手续费分子
    pub fee_denominator: u64,       // 手续费分母
    pub reserve_a: u64,             // Token A 储备量
    pub reserve_b: u64,             // Token B 储备量
    pub bump: u8,                   // PDA Bump
}

impl LiquidityPool {
    pub const LEN: usize = 8 + // discriminator
        32 + // authority
        32 + // token_a_mint
        32 + // token_b_mint
        32 + // token_a_vault
        32 + // token_b_vault
        32 + // lp_token_mint
        8 +  // fee_numerator
        8 +  // fee_denominator
        8 +  // reserve_a
        8 +  // reserve_b
        1;   // bump
}
```

### instructions.rs - 指令实现

```rust
use anchor_lang::prelude::*;
use anchor_spl::token::{self, Token, TokenAccount, Mint, MintTo, Transfer};
use crate::state::*;
use crate::errors::*;

// 初始化流动性池
pub fn initialize(
    ctx: Context<Initialize>,
    fee_numerator: u64,
    fee_denominator: u64,
) -> Result<()> {
    let pool = &mut ctx.accounts.pool;
    
    require!(fee_denominator > 0, SwapError::InvalidFee);
    require!(fee_numerator <= fee_denominator, SwapError::InvalidFee);
    
    pool.authority = ctx.accounts.authority.key();
    pool.token_a_mint = ctx.accounts.token_a_mint.key();
    pool.token_b_mint = ctx.accounts.token_b_mint.key();
    pool.token_a_vault = ctx.accounts.token_a_vault.key();
    pool.token_b_vault = ctx.accounts.token_b_vault.key();
    pool.lp_token_mint = ctx.accounts.lp_token_mint.key();
    pool.fee_numerator = fee_numerator;
    pool.fee_denominator = fee_denominator;
    pool.reserve_a = 0;
    pool.reserve_b = 0;
    pool.bump = *ctx.bumps.get("pool").unwrap();
    
    Ok(())
}

// 添加流动性
pub fn add_liquidity(
    ctx: Context<AddLiquidity>,
    amount_a: u64,
    amount_b: u64,
) -> Result<()> {
    let pool = &mut ctx.accounts.pool;
    
    // 转移 Token A 到金库
    token::transfer(
        CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            Transfer {
                from: ctx.accounts.user_token_a.to_account_info(),
                to: ctx.accounts.token_a_vault.to_account_info(),
                authority: ctx.accounts.user.to_account_info(),
            },
        ),
        amount_a,
    )?;
    
    // 转移 Token B 到金库
    token::transfer(
        CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            Transfer {
                from: ctx.accounts.user_token_b.to_account_info(),
                to: ctx.accounts.token_b_vault.to_account_info(),
                authority: ctx.accounts.user.to_account_info(),
            },
        ),
        amount_b,
    )?;
    
    // 计算 LP Token 数量
    let lp_amount = if pool.reserve_a == 0 && pool.reserve_b == 0 {
        // 首次添加流动性
        (amount_a.checked_mul(amount_b).unwrap() as f64).sqrt() as u64
    } else {
        // 按比例计算
        std::cmp::min(
            amount_a.checked_mul(ctx.accounts.lp_token_mint.supply).unwrap() / pool.reserve_a,
            amount_b.checked_mul(ctx.accounts.lp_token_mint.supply).unwrap() / pool.reserve_b,
        )
    };
    
    // 铸造 LP Token
    let seeds = &[
        b"pool".as_ref(),
        pool.token_a_mint.as_ref(),
        pool.token_b_mint.as_ref(),
        &[pool.bump],
    ];
    let signer = &[&seeds[..]];
    
    token::mint_to(
        CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            MintTo {
                mint: ctx.accounts.lp_token_mint.to_account_info(),
                to: ctx.accounts.user_lp_token.to_account_info(),
                authority: pool.to_account_info(),
            },
            signer,
        ),
        lp_amount,
    )?;
    
    // 更新储备量
    pool.reserve_a = pool.reserve_a.checked_add(amount_a).unwrap();
    pool.reserve_b = pool.reserve_b.checked_add(amount_b).unwrap();
    
    Ok(())
}

// 交换代币
pub fn swap(
    ctx: Context<Swap>,
    amount_in: u64,
    minimum_amount_out: u64,
) -> Result<()> {
    let pool = &ctx.accounts.pool;
    
    // 计算输出金额（扣除手续费）
    let amount_in_with_fee = amount_in
        .checked_mul(pool.fee_denominator - pool.fee_numerator)
        .unwrap();
    
    let amount_out = amount_in_with_fee
        .checked_mul(pool.reserve_b)
        .unwrap()
        .checked_div(
            pool.reserve_a
                .checked_mul(pool.fee_denominator)
                .unwrap()
                .checked_add(amount_in_with_fee)
                .unwrap()
        )
        .unwrap();
    
    require!(amount_out >= minimum_amount_out, SwapError::SlippageExceeded);
    
    // 执行转账
    // ... (转账逻辑)
    
    Ok(())
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,
    
    #[account(
        init,
        payer = authority,
        space = LiquidityPool::LEN,
        seeds = [b"pool", token_a_mint.key().as_ref(), token_b_mint.key().as_ref()],
        bump
    )]
    pub pool: Account<'info, LiquidityPool>,
    
    pub token_a_mint: Account<'info, Mint>,
    pub token_b_mint: Account<'info, Mint>,
    
    #[account(
        init,
        payer = authority,
        token::mint = token_a_mint,
        token::authority = pool
    )]
    pub token_a_vault: Account<'info, TokenAccount>,
    
    #[account(
        init,
        payer = authority,
        token::mint = token_b_mint,
        token::authority = pool
    )]
    pub token_b_vault: Account<'info, TokenAccount>,
    
    #[account(
        init,
        payer = authority,
        mint::decimals = 6,
        mint::authority = pool
    )]
    pub lp_token_mint: Account<'info, Mint>,
    
    pub token_program: Program<'info, Token>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>,
}

// ... 其他 Accounts 结构
```

### errors.rs - 错误定义

```rust
use anchor_lang::prelude::*;

#[error_code]
pub enum SwapError {
    #[msg("Invalid fee configuration")]
    InvalidFee,
    
    #[msg("Slippage tolerance exceeded")]
    SlippageExceeded,
    
    #[msg("Insufficient liquidity")]
    InsufficientLiquidity,
    
    #[msg("Invalid token mint")]
    InvalidTokenMint,
}
```

## Go 客户端集成

```go
package main

import (
    "context"
    "github.com/gagliardetto/solana-go"
    "github.com/gagliardetto/solana-go/rpc"
)

func SwapTokens() {
    // 连接到 RPC
    client := rpc.New("https://api.devnet.solana.com")
    
    // 构建交换指令
    // ... (使用生成的 Go 绑定代码)
    
    // 发送交易
    // ...
}
```

## 部署和测试

```bash
# 构建合约
anchor build

# 运行测试
anchor test

# 部署到 Devnet
anchor deploy --provider.cluster devnet

# 生成 Go 绑定
anchor generate --lang=go --path=./programs/token-swap
```

## 安全注意事项

1. **重入攻击防护** - Solana 的账户模型天然防止重入
2. **整数溢出检查** - 使用 `checked_*` 方法
3. **滑点保护** - 设置最小输出金额
4. **权限验证** - 使用 Anchor 的账户约束
5. **PDA 安全** - 正确使用 seeds 和 bump

## 参考资料

- [Anchor 文档](https://www.anchor-lang.com/)
- [Solana Cookbook](https://solanacookbook.com/)
- [SPL Token Program](https://spl.solana.com/token)
